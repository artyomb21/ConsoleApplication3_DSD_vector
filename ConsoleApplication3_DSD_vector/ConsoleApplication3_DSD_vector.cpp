//С начало создаем наш объект с типом данных Point потом внутри объекта создаем поле для примера x и методы для него ввод и вывод данных,
//то есть возможность создать и посмотреть данные. эти объекты с таким прототипом будут являтся нашими элементами динамического масива 
//осталось создать объект в котором поля будут указатель на динамический массив и поле инт количество элементов в нем , а так же методы
//для работы с ними , а иммнно :
//метод создание элементов, удаление нужный нам элемент и вывод на экран все данные объекта то есть данные полей нашего элемента, то есть
//объекта.начинаем метод создание то есть add(), проверяем если количество нашего элемента 0 то, создаем динамический массив с размером на один
//мы увеличили на 1 n + 1 и вызываем метод лля объекта с индексом - 1 потомучто индексы начинаются с нуля.Иначе создаем временный
//указатель на на p  то есть имеющий нам указатель на массив, потом увеличиваем размер на один n + 1 и создаем новый динамический массив с нужным нам
//размером потом с помощю цыкла копируем данные и в конце вызываем метод ввести данные для последнего объекта то есть индекс равно количество - 1
//после копирование удаляем временный наш указатель масивов delete[] t.Удаление нужного нам элемента  написано мной методом в котором
//в параметрах пишется номер объекта(не индекса).С начало создаем указатель на на указатель на динамический массив и инициализируем
//адрес на него то, есть на t.Потом создаем новый массив с одним элементом меньше прежнего, теперь мы имеем два массива  t это старый массив
//с старыми данными и новый пустой не инициализированный p.том с помощю цыкла for у нас произойдет копированиес условие если итератор равно
//с индексом нужнего элемента нами выбранного то, инкреминтируем итератор на + 1, то есть перескакиваем на один.после копирование удаляем
//временный динамический массив.Я считаю нужным что, в функции main должен быть только основная логика с функциями. и после нашего тестирование
//а иммено создание вывод удаление вывод работает хорошо. В качестве оссобенности нашей структуры могу сказать , что перезапись будет происходит 
//медленно нодоступ очень быстрим. По сути после каждого добовление приходится содать элементы и копировать заного , и мы конечно же в курсе 
//про функцию капайсити для создание запасных элементов
#include <iostream>
#include <Windows.h>
using namespace std;
class Point
{
	int x;
public:
	Point() :x(0)
	{}
	Point(int x, int y) :x(x)
	{
	}
	void input_info()
	{
		cout << "input x" << endl;
		cin >> x;
		
	}
	void show()
	{
		cout << "x = " << x << endl;
	}
};

class Dinamic_array
{
private:
	Point* p;
	int n;
public:
	Dinamic_array() :p(NULL), n(0) {}
	void add()
	{
		if (n == 0)
		{
			n = 1;
			p = new Point[n];
			p[n - 1].input_info();
		}
		else {
			Point* t = p;
			++n;
			p = new Point[n];
			for (size_t i = 0; i < n; i++)
			{
				p[i] = t[i];
			}
			p[n - 1].input_info();
			delete[] t;
		}
	}
	void delete_object(int deleted_element_number)
	{
		if (n == 0)return;
		--deleted_element_number;
		Point* t = p; 
		p = new Point[n - 1];
		//t[i] p[j];
		for (int i = 0, j = 0; i < n; ++i, ++j)
		{
			if (i == deleted_element_number)
			{
				++i;
			}
			p[j] = t[i];
		}
		--n;
		delete[] t;
	}
	void show_objects()
	{
		for (int i = 0; i < n; i++)
		{
			p[i].show();
		}
	}
};
int main()
{
	Dinamic_array object_1;
	object_1.add();
	object_1.add();
	object_1.add();
	object_1.show_objects();
	object_1.delete_object(2);
	cout << endl << endl;
	object_1.show_objects();
}
